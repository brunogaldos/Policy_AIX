import { promises as fsp } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import crypto from "crypto";
import { PolicySynthAgent } from "./agent.js";
import { PsAiModelType, PsAiModelSize } from "../aiModelTypes.js";
export var AgentPhase;
(function (AgentPhase) {
    AgentPhase[AgentPhase["START"] = 0] = "START";
    AgentPhase[AgentPhase["PLAN"] = 1] = "PLAN";
    AgentPhase[AgentPhase["CALL_TOOL"] = 2] = "CALL_TOOL";
    AgentPhase[AgentPhase["OBSERVE"] = 3] = "OBSERVE";
    AgentPhase[AgentPhase["FINISH"] = 4] = "FINISH";
})(AgentPhase || (AgentPhase = {}));
export class PolicySynthAgentTask extends PolicySynthAgent {
    systemPrompt;
    static TOOLS = [];
    messages = [];
    pendingToolCalls = [];
    phase = AgentPhase.START;
    runDir;
    dirs;
    constructor(agent, memory, taskId, systemPrompt) {
        super(agent, memory, 0, 100);
        this.systemPrompt = systemPrompt;
        const here = path.dirname(fileURLToPath(import.meta.url));
        this.runDir = path.join(here, "agent_runs", taskId);
        this.dirs = {
            scratch: path.join(this.runDir, "scratch"),
            memory: path.join(this.runDir, "memory"),
            artifacts: path.join(this.runDir, "artifacts"),
            logs: path.join(this.runDir, "logs"),
        };
        Promise.all(Object.values(this.dirs).map((d) => fsp.mkdir(d, { recursive: true })));
    }
    async *run(userMessage) {
        this.messages.push({ role: "system", message: this.systemPrompt.trim() });
        this.messages.push({ role: "user", message: userMessage });
        while (this.phase !== AgentPhase.FINISH) {
            switch (this.phase) {
                case AgentPhase.START:
                    this.phase = AgentPhase.PLAN;
                    break;
                case AgentPhase.PLAN:
                    await this.planStep();
                    break;
                case AgentPhase.CALL_TOOL:
                    await this.callToolStep();
                    break;
                case AgentPhase.OBSERVE:
                    this.phase = this.isDone() ? AgentPhase.FINISH : AgentPhase.PLAN;
                    break;
            }
            yield this.messages.at(-1);
        }
    }
    isDone() {
        const last = this.messages.at(-1);
        return !!last && last.role === "assistant" && !last.toolCall;
    }
    fs = {
        mktemp: (bucket, prefix = "tmp", ext = ".txt") => {
            const ts = Date.now();
            const rnd = crypto.randomBytes(3).toString("hex");
            return path.join(this.dirs[bucket], `${prefix}-${ts}-${rnd}${ext}`);
        },
        writeText: async (bucket, rel, data) => {
            const file = path.join(this.dirs[bucket], rel);
            await fsp.mkdir(path.dirname(file), { recursive: true });
            await fsp.writeFile(file, data, "utf8");
            return file;
        },
        readText: async (bucket, rel) => {
            return fsp.readFile(path.join(this.dirs[bucket], rel), "utf8");
        },
        writeJSON: async (bucket, rel, obj, pretty = 2) => {
            const txt = JSON.stringify(obj, null, pretty);
            return this.fs.writeText(bucket, rel, txt);
        },
        readJSON: async (bucket, rel) => {
            const txt = await this.fs.readText(bucket, rel);
            return JSON.parse(txt);
        },
        list: async (bucket, rel = "") => {
            const dir = path.join(this.dirs[bucket], rel);
            return fsp.readdir(dir, { withFileTypes: true });
        },
    };
    async planStep() {
        const allow = new Set(this.policy());
        const result = await this.callModel(PsAiModelType.TextReasoning, PsAiModelSize.Large, this.messages, {
            parseJson: false,
            functions: this.constructor.TOOLS,
            toolChoice: "auto",
            allowedTools: [...allow],
        });
        let assistantMsg;
        if (result &&
            typeof result === "object" &&
            Array.isArray(result.toolCalls) &&
            result.toolCalls.length) {
            const [first, ...rest] = result.toolCalls;
            this.pendingToolCalls = rest;
            assistantMsg = { role: "assistant", message: "", toolCall: first };
        }
        else {
            const text = typeof result === "string" ? result : JSON.stringify(result);
            assistantMsg = { role: "assistant", message: text };
        }
        this.messages.push(assistantMsg);
        this.phase = assistantMsg.toolCall
            ? AgentPhase.CALL_TOOL
            : AgentPhase.OBSERVE;
    }
    async callToolStep() {
        const call = this.messages.at(-1).toolCall;
        const allow = new Set(this.policy());
        if (!allow.has(call.name)) {
            this.logger.error(`Policy violation: attempted to call disallowed tool ${call.name}`);
            const msg = `Tool ${call.name} is not allowed by policy`;
            this.messages.push({ role: "tool", name: call.name, message: msg });
            this.phase = AgentPhase.OBSERVE;
            return;
        }
        const result = await this.runTool(call.name, call.arguments);
        this.messages.push({ role: "tool", name: call.name, message: result });
        if (this.pendingToolCalls.length) {
            const next = this.pendingToolCalls.shift();
            this.messages.push({ role: "assistant", message: "", toolCall: next });
            this.phase = AgentPhase.CALL_TOOL;
        }
        else {
            this.phase = AgentPhase.OBSERVE;
        }
    }
    async runTool(name, args) {
        const artefact = await this.fs.writeJSON("artifacts", `${name}.json`, args);
        return `stored artefact at ${artefact}`;
    }
}
//# sourceMappingURL=agentTask.js.map