import { BaseChatModel } from "../aiModels/baseChatModel.js";
import { PsAiModelType, PsAiModelSize } from "../aiModelTypes.js";
import { PolicySynthAgentBase } from "./agentBase.js";
export declare class PsAiModelManager extends PolicySynthAgentBase {
    models: Map<string, BaseChatModel>;
    modelsByType: Map<PsAiModelType, BaseChatModel>;
    modelIds: Map<string, number>;
    modelIdsByType: Map<PsAiModelType, number>;
    rateLimits: PsModelRateLimitTracking;
    userId: number;
    agentId: number;
    maxTokensOut: number;
    modelTemperature: number;
    reasoningEffort: "low" | "medium" | "high";
    maxThinkingTokens: number;
    limitedLLMmaxRetryCount: number;
    mainLLMmaxRetryCount: number;
    modelCallTimeoutMs: number;
    constructor(aiModels: PsAiModelAttributes[], accessConfiguration: YpGroupPrivateAccessConfiguration[], maxTokensOut: number | undefined, modelTemperature: number | undefined, reasoningEffort: "low" | "medium" | "high" | undefined, maxThinkingTokens: number | undefined, agentId: number, userId: number);
    initializeOneModelFromEnv(): BaseChatModel | undefined;
    initializeModels(aiModels: PsAiModelAttributes[], accessConfiguration: YpGroupPrivateAccessConfiguration[]): void;
    /**
     * Creates a one-off ephemeral model instance, merging overrides from `options`.
     * If provider is not specified, we'll reuse the provider from the fallback model
     * or environment. This returns `undefined` if no ephemeral override was requested.
     */
    private createEphemeralModel;
    private getApiKeyForProvider;
    callModel(modelType: PsAiModelType, modelSize: PsAiModelSize, messages: PsModelMessage[], options: PsCallModelOptions): Promise<any>;
    callTextModel(modelType: PsAiModelType, modelSize: PsAiModelSize, messages: PsModelMessage[], options: PsCallModelOptions): Promise<any>;
    static prohibitedContentErrors: string[];
    static isProhibitedContentError: (err: any) => boolean;
    private logDetailedServerError;
    /**
     * Actually does the call against the chosen model,
     * with your retry logic, parseJson, usage tracking, etc.
     */
    private runTextModelCall;
    private callWithTimeout;
    private sleepBeforeRetry;
    callEmbeddingModel(messages: PsModelMessage[]): Promise<null>;
    callMultiModalModel(messages: PsModelMessage[]): Promise<null>;
    callAudioModel(messages: PsModelMessage[]): Promise<null>;
    callVideoModel(messages: PsModelMessage[]): Promise<null>;
    callImageModel(messages: PsModelMessage[]): Promise<null>;
    /**
     * Returns the price configuration for a given model call. This will first
     * check for an explicit model override via `options` and attempt to load that
     * model configuration from the database. If not found, it will fall back to
     * the currently loaded models using the same fallback logic as `callTextModel`.
     */
    getModelPriceConfiguration(modelType: PsAiModelType, modelSize: PsAiModelSize, options: PsCallModelOptions): Promise<PsBaseModelPriceConfiguration | undefined>;
    saveTokenUsage(prices: PsBaseModelPriceConfiguration, modelType: PsAiModelType, modelSize: PsAiModelSize, tokensIn: number, cachedInTokens: number, tokensOut: number, modelIdOverride?: number): Promise<void>;
    getTokensFromMessages(messages: PsModelMessage[]): Promise<number>;
}
//# sourceMappingURL=agentModelManager.d.ts.map