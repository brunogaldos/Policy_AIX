"use strict";const E=require("../config/index.cjs"),g=require("../util/logger.cjs"),t=require("../oauth2-client/index.cjs"),l=require("../token-storage/index.cjs"),w=require("../oauth2-client/state-pkce.cjs"),k=require("../util/url.cjs"),q=require("./helpers.cjs"),y=require("../oauth2-client/enums.cjs");class d{static async getTokens(r){const{clientId:s,oauthThreshold:u,prefix:c}=E.get(r);if(!s)throw new Error("Client ID is required");const i=await l.get();if(i&&!r?.forceRenew&&!r?.query?.code&&!q.tokensWillExpireWithinThreshold(u,i.tokenExpiry))return i;if(i)try{await t.default.revokeToken(r),await d.deleteTokens()}catch(e){g.FRLogger.warn("Existing tokens could not be revoked or deleted",e)}if(r?.query?.code&&r?.query?.state){const{state:e,verifier:n}=w.getStoredAuthUrlValues(s,c);if(e===void 0||n===void 0)throw new Error("`state` and/or `verifier` not found in sessionStorage. Debugging: sessionStorage is not accessible in separate tabs.");return await this.tokenExchange(r,{state:e,verifier:n})}const o=Object.assign({},r);delete o.forceRenew;const[a,h]=w.generateAndStoreAuthUrlValues({...o,clientId:s,prefix:c,responseType:y.ResponseType.Code});if(r||(r={}),r.skipBackgroundRequest!==!0){try{const e=new URL(await t.default.getAuthCodeByIframe(a));if(e.searchParams.get("error"))throw Error(`${e.searchParams.get("error_description")}`);if(!e.searchParams.get("code"))throw Error(t.allowedErrors.AuthenticationConsentRequired);const n=k.parseQuery(e.toString());r.query=n}catch(e){if(!(e instanceof Error)||r?.login!=="redirect"||t.allowedErrors.AuthenticationIsRequired!==e.message&&t.allowedErrors.AuthenticationConsentRequired!==e.message&&t.allowedErrors.AuthorizationTimeout!==e.message&&t.allowedErrors.FailedToFetch!==e.message&&t.allowedErrors.NetworkError!==e.message&&t.allowedErrors.InteractionNotAllowed!==e.message&&t.allowedErrors.RequestRequiresConsent!==e.message&&!e.message.includes(t.allowedErrors.LoginRequired)&&!e.message.includes(t.allowedErrors.CORSError))throw e;const n=await t.default.createAuthorizeUrl(a);return h(),location.assign(n)}return await this.tokenExchange(r,{state:a.state,verifier:a.verifier})}const f=await t.default.createAuthorizeUrl(a);return h(),location.assign(f)}static async deleteTokens(){await l.remove()}static async tokenExchange(r,s){if(r.query?.state!==s.state)throw new Error("State mismatch");if(!r.query?.code||Array.isArray(r.query?.code))throw new Error("Failed to acquire authorization code");const u=r.query?.code,c=s.verifier,i={...r,authorizationCode:u,verifier:c},o=await t.default.getOAuth2Tokens(i);if(!o||!o.accessToken)throw new Error("Unable to exchange authorization for tokens");try{await l.set(o)}catch(a){g.FRLogger.error("Failed to store tokens",a)}return o}}module.exports=d;
