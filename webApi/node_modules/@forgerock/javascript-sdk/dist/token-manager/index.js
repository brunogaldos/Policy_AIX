import w from "../config/index.js";
import { FRLogger as l } from "../util/logger.js";
import c, { allowedErrors as t } from "../oauth2-client/index.js";
import d from "../token-storage/index.js";
import { getStoredAuthUrlValues as k, generateAndStoreAuthUrlValues as y } from "../oauth2-client/state-pkce.js";
import { parseQuery as q } from "../util/url.js";
import { tokensWillExpireWithinThreshold as E } from "./helpers.js";
import { ResponseType as A } from "../oauth2-client/enums.js";
class f {
  /**
     * @function getTokens - Retrieves OAuth2 tokens from the server or local storage.
     * @param {Object} options - Options for retrieving tokens.
     * @param {boolean} [options.forceRenew] - If true, forces a new token request even if tokens are already stored.
     * @param {string} [options.login] - Specifies the type of login: 'embedded' or 'redirect'.
     * @param {boolean} [options.skipBackgroundRequest] - If true, skips the background request to get tokens without redirect.
     * @param {Object} [options.query] - Query key-value pairs to convert to URL parameters for the /authorize request.
     * @param {string} [options.query.code] - Authorization code from the redirect URL.
     * @param {string} [options.query.state] - State parameter from the redirect URL.
     * @returns {Promise<OAuth2Tokens | void>} - Returns a promise that resolves to the retrieved tokens or void.
     * @throws {Error} - Throws an error if the client ID is not provided, if tokens cannot be exchanged, or if there is a state mismatch.
     *
     Example 1:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       forceRenew: true, // If you want to get new tokens, despite existing ones
       login: 'embedded', // If user authentication is handled in-app
       serverConfig: {
         timeout: 5000,
       },
     });
     ```
  
     Example 2:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       forceRenew: false, // Will immediately return stored tokens, if they exist
       login: 'redirect', // If user authentication is handled in external Web app
     });
     ```
  
     Example 3:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       query: {
         code: 'lFJQYdoQG1u7nUm8 ... ', // Authorization code from redirect URL
         state: 'MTY2NDkxNTQ2Nde3D ... ', // State from redirect URL
       },
     });
     ```
  
     Example 4:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       skipBackgroundRequest: true, // OPTIONAL; this will skip the iframe request to silently get tokens w/o redirect
     });
     ```
     */
  static async getTokens(r) {
    const { clientId: i, oauthThreshold: h, prefix: u } = w.get(r);
    if (!i)
      throw new Error("Client ID is required");
    const s = await d.get();
    if (s && !r?.forceRenew && !r?.query?.code && !E(h, s.tokenExpiry))
      return s;
    if (s)
      try {
        await c.revokeToken(r), await f.deleteTokens();
      } catch (e) {
        l.warn("Existing tokens could not be revoked or deleted", e);
      }
    if (r?.query?.code && r?.query?.state) {
      const { state: e, verifier: n } = k(i, u);
      if (e === void 0 || n === void 0)
        throw new Error(
          "`state` and/or `verifier` not found in sessionStorage. Debugging: sessionStorage is not accessible in separate tabs."
        );
      return await this.tokenExchange(r, { state: e, verifier: n });
    }
    const o = Object.assign({}, r);
    delete o.forceRenew;
    const [a, g] = y({
      ...o,
      clientId: i,
      prefix: u,
      responseType: A.Code
    });
    if (r || (r = {}), r.skipBackgroundRequest !== !0) {
      try {
        const e = new URL(await c.getAuthCodeByIframe(a));
        if (e.searchParams.get("error"))
          throw Error(`${e.searchParams.get("error_description")}`);
        if (!e.searchParams.get("code"))
          throw Error(t.AuthenticationConsentRequired);
        const n = q(e.toString());
        r.query = n;
      } catch (e) {
        if (!(e instanceof Error) || r?.login !== "redirect" || t.AuthenticationIsRequired !== e.message && t.AuthenticationConsentRequired !== e.message && t.AuthorizationTimeout !== e.message && t.FailedToFetch !== e.message && t.NetworkError !== e.message && t.InteractionNotAllowed !== e.message && t.RequestRequiresConsent !== e.message && // Check for Ping Identity Login Required error
        // Long message, so just check substring
        !e.message.includes(t.LoginRequired) && // Safari has a very long error message, so we check for a substring
        !e.message.includes(t.CORSError))
          throw e;
        const n = await c.createAuthorizeUrl(a);
        return g(), location.assign(n);
      }
      return await this.tokenExchange(r, {
        state: a.state,
        verifier: a.verifier
      });
    }
    const m = await c.createAuthorizeUrl(a);
    return g(), location.assign(m);
  }
  static async deleteTokens() {
    await d.remove();
  }
  static async tokenExchange(r, i) {
    if (r.query?.state !== i.state)
      throw new Error("State mismatch");
    if (!r.query?.code || Array.isArray(r.query?.code))
      throw new Error("Failed to acquire authorization code");
    const h = r.query?.code, u = i.verifier, s = { ...r, authorizationCode: h, verifier: u }, o = await c.getOAuth2Tokens(s);
    if (!o || !o.accessToken)
      throw new Error("Unable to exchange authorization for tokens");
    try {
      await d.set(o);
    } catch (a) {
      l.error("Failed to store tokens", a);
    }
    return o;
  }
}
export {
  f as default
};
