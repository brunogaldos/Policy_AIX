import z from "../config/index.js";
import { ActionTypes as S } from "../config/enums.js";
import T from "../fr-auth/index.js";
import { StepType as d } from "../fr-auth/enums.js";
import y from "../fr-auth/fr-step.js";
import g from "../token-manager/index.js";
import f from "../token-storage/index.js";
import { withTimeout as I } from "../util/timeout.js";
import { newTokenRequired as R, examineForIGAuthzHeader as v, normalizeIGJSONResponseToAdviceJSON as k, examineForIGAuthz as x, normalizeIGRedirectResponseToAdviceJSON as q, examineForRESTAuthz as E, normalizeRESTJSON as N, buildAuthzOptions as O, isAuthzStep as F, hasAuthzAdvice as H, addAuthzInfoToURL as U, addAuthzInfoToHeaders as G } from "./helpers.js";
import J from "../util/middleware.js";
class D {
  /**
   * Makes a request using the specified options.
   *
   * @param options The options to use when making the request
   */
  static async request(e) {
    let r = await this._request(e, !1), t, a = !1;
    if (R(r, e.requiresNewToken) && (r = await this._request(e, !0)), e.authorization && e.authorization.handleStep)
      if (r.status === 401 && v(r.headers) ? (a = !0, t = k(r)) : r.redirected && x(r) ? (a = !0, t = q(r)) : await E(r) && (t = await N(r)), t && t.advices) {
        const { middleware: n, realmPath: i, serverConfig: o } = z.get(e.authorization.config), s = O(
          t,
          o.baseUrl,
          e.timeout,
          i,
          o.paths
        ), c = new URL(s.url), u = c.searchParams.get("authIndexType"), m = c.searchParams.get("authIndexValue"), w = J(
          {
            url: new URL(s.url),
            init: s.init
          },
          {
            type: S.StartAuthenticate,
            payload: { type: u, tree: m }
          }
        ), { url: p, init: A } = w(n);
        s.url = p.toString(), s.init = A;
        const h = await this._request(s, !1);
        if (!await F(h))
          throw new Error('Error: Initial response from auth server not a "step".');
        if (!H(t))
          throw new Error("Error: Transactional or Service Advice is empty.");
        await this.stepIterator(h, e.authorization.handleStep);
        const l = await f.get();
        a ? e.url = U(e.url, t.advices, l) : e.init.headers = G(
          e.init,
          t.advices,
          l
        ), r = await this._request(e, !1);
      } else
        throw new Error("Error: Unable to process advice");
    return r;
  }
  static async setAuthHeaders(e, r) {
    let t = await f.get();
    return t && t.accessToken && (t = await g.getTokens({ forceRenew: r }), t && t.accessToken && e.set("Authorization", `Bearer ${t.accessToken}`)), e;
  }
  static async stepIterator(e, r) {
    const t = await e.json(), a = new y(t);
    return new Promise(async (n, i) => {
      async function o(s) {
        const c = await r(s), u = await T.next(c, { tree: "", type: "" });
        u.type === d.LoginSuccess ? n() : u.type === d.LoginFailure ? i("Authentication tree failure.") : o(u);
      }
      o(a);
    });
  }
  static async _request(e, r) {
    const { url: t, init: a, timeout: n } = e;
    let i = new Headers(a.headers || {});
    return e.authorization && i.set("x-authenticate-response", "header"), e.bypassAuthentication || (i = await this.setAuthHeaders(i, r)), a.headers = i, I(fetch(t, a), n);
  }
}
export {
  D as default
};
