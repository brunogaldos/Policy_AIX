import { getEndpointPath as S, resolve as C, stringify as g } from "../util/url.js";
import { FRLogger as y } from "../util/logger.js";
function P(e, t, n) {
  const i = new Headers(e.headers);
  return t.AuthenticateToServiceConditionAdvice ? i.set("X-Tree", t.AuthenticateToServiceConditionAdvice[0]) : t.TransactionConditionAdvice && i.set("X-TxID", t.TransactionConditionAdvice[0]), n && n.idToken && i.set("X-IdToken", n.idToken), i;
}
function W(e, t, n) {
  const i = new URL(e);
  if (t.TransactionConditionAdvice) {
    const c = t.TransactionConditionAdvice[0];
    i.searchParams.append("_txid", c);
  }
  return n && n.idToken && i.searchParams.append("_idtoken", n.idToken), i.toString();
}
function b(e, t, n, i, c) {
  const r = e.advices && e.advices.AuthenticateToServiceConditionAdvice, a = e.advices && e.advices.TransactionConditionAdvice;
  let d = "", s = "";
  r ? (d = r.reduce((o, u) => {
    const l = o && ` ${o}`;
    return o = `${u}${l}`, o;
  }, ""), s = "AuthenticateToServiceConditionAdvice") : a && (d = a.reduce((o, u) => {
    const l = o && ` ${o}`;
    return o = `${u}${l}`, o;
  }, ""), s = "TransactionConditionAdvice");
  const v = "<Advices><AttributeValuePair>", h = `<Attribute name="${s}"/>`, T = `<Value>${d}</Value>`, f = `${v}${h}${T}</AttributeValuePair></Advices>`, p = S("authenticate", i, c), m = {
    authIndexType: "composite_advice",
    authIndexValue: f
  };
  return {
    init: {
      method: "POST",
      credentials: "include",
      headers: new Headers({
        "Accept-API-Version": "resource=2.0, protocol=1.0"
      })
    },
    timeout: n,
    url: C(t, `${p}?${g(m)}`)
  };
}
function H(e) {
  return (e.headers.get("Content-Type") || "").includes("html") && e.url.includes("composite_advice");
}
function L(e) {
  return (e.get("WWW-Authenticate") || "").includes("advices");
}
async function w(e) {
  return !!(await e.clone().json()).advices;
}
function A(e) {
  const n = new URL(e).searchParams.get("authIndexValue") || "", i = new DOMParser(), c = decodeURIComponent(n), a = i.parseFromString(c, "application/xml").querySelector("Value");
  return a ? a.innerHTML : "";
}
function V(e) {
  const n = (e.split(",") || []).find((c) => c.includes("advices")) || "";
  let i;
  try {
    const c = n.match(/"(\S+)"/), r = c ? c[1] : "", a = atob(r);
    return i = JSON.parse(a), i;
  } catch {
    y.error("Could not parse advices value from WWW-Authenticate header");
  }
  return {};
}
function z(e) {
  return e.advices && e.advices.AuthenticateToServiceConditionAdvice ? Array.isArray(e.advices.AuthenticateToServiceConditionAdvice) && e.advices.AuthenticateToServiceConditionAdvice.length > 0 : e.advices && e.advices.TransactionConditionAdvice ? Array.isArray(e.advices.TransactionConditionAdvice) && e.advices.TransactionConditionAdvice.length > 0 : !1;
}
async function F(e) {
  return !!(await e.clone().json()).callbacks;
}
function O(e, t) {
  return typeof t == "function" ? t(e) : e.status === 401;
}
function U(e) {
  const t = {};
  return e.url.includes("AuthenticateToServiceConditionAdvice") ? t.AuthenticateToServiceConditionAdvice = [A(e.url)] : t.TransactionConditionAdvice = [A(e.url)], {
    resource: "",
    actions: {},
    attributes: {},
    advices: t,
    ttl: 0
  };
}
function J(e) {
  const t = e.headers.get("WWW-Authenticate") || "", n = V(t);
  return {
    resource: "",
    actions: {},
    attributes: {},
    advices: n,
    ttl: 0
  };
}
async function N(e) {
  return await e.json();
}
export {
  P as addAuthzInfoToHeaders,
  W as addAuthzInfoToURL,
  b as buildAuthzOptions,
  H as examineForIGAuthz,
  L as examineForIGAuthzHeader,
  w as examineForRESTAuthz,
  V as getAdvicesFromHeader,
  z as hasAuthzAdvice,
  F as isAuthzStep,
  O as newTokenRequired,
  J as normalizeIGJSONResponseToAdviceJSON,
  U as normalizeIGRedirectResponseToAdviceJSON,
  N as normalizeRESTJSON
};
