"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const l=require("../config/enums.cjs"),w=require("../config/index.cjs"),p=require("../token-storage/index.cjs"),y=require("../util/http.cjs"),_=require("../util/pkce.cjs"),q=require("../util/timeout.cjs"),f=require("../util/url.cjs"),T=require("../util/middleware.cjs"),k={AuthenticationConsentRequired:"Authentication or consent required",AuthenticationIsRequired:"Authentication is required.",AuthorizationTimeout:"Authorization timed out",FailedToFetch:"Failed to fetch",NetworkError:"NetworkError when attempting to fetch resource.",CORSError:"Cross-origin redirection",InteractionNotAllowed:"The request requires some interaction that is not allowed.",LoginRequired:"User authentication is required",RequestRequiresConsent:"The request requires consent."};class A{static async createAuthorizeUrl(e){const{clientId:n,middleware:s,redirectUri:t,scope:i}=w.get(e),r={...e.query,client_id:n,redirect_uri:t,response_type:e.responseType,scope:i,state:e.state,...e.prompt?{prompt:e.prompt}:{}};if(e.verifier){const c=await _.createChallenge(e.verifier);r.code_challenge=c,r.code_challenge_method="S256"}const o=T({url:new URL(this.getUrl("authorize",r,e)),init:{}},{type:l.ActionTypes.Authorize}),{url:a}=o(s);return a.toString()}static async getAuthCodeByIframe(e){const n=await this.createAuthorizeUrl({...e,prompt:"none"}),{serverConfig:s}=w.get(e);return new Promise((t,i)=>{const r=document.createElement("iframe"),o=()=>{};let a=o,c=o,d=0;c=()=>{clearTimeout(d),r.removeEventListener("load",a),r.remove()},a=()=>{if(r.contentWindow){const u=r.contentWindow.location.href;(this.containsAuthCode(u)||this.containsAuthError(u))&&(c(),t(u))}},d=setTimeout(()=>{c(),i(new Error(k.AuthorizationTimeout))},s.timeout),r.style.display="none",r.addEventListener("load",a),document.body.appendChild(r),r.src=n})}static async getOAuth2Tokens(e){const{clientId:n,redirectUri:s}=w.get(e),t={client_id:n,code:e.authorizationCode,grant_type:"authorization_code",redirect_uri:s};e.verifier&&(t.code_verifier=e.verifier);const i=f.stringify(t),r={body:i,headers:new Headers({"Content-Length":i.length.toString(),"Content-Type":"application/x-www-form-urlencoded"}),method:"POST"},o=await this.request("accessToken",void 0,!1,r,e),a=await this.getBody(o);if(o.status!==200){const u=typeof a=="string"?`Expected 200, received ${o.status}`:this.parseError(a);throw new Error(u)}const c=a;if(!c.access_token)throw new Error("Access token not found in response");let d;return c.expires_in&&(d=Date.now()+c.expires_in*1e3),{accessToken:c.access_token,idToken:c.id_token,refreshToken:c.refresh_token,tokenExpiry:d}}static async getUserInfo(e){const n=await this.request("userInfo",void 0,!0,void 0,e);if(n.status!==200)throw new Error(`Failed to get user info; received ${n.status}`);return await n.json()}static async endSession(e){const n={...e};delete n.redirect,delete n.logoutRedirectUri;const s={},t=await p.get();s.id_token_hint=t&&t.idToken||(e&&"idToken"in e?e.idToken:"");const i=await this.request("endSession",s,!0,void 0,n,{redirect:e?.redirect,logoutRedirectUri:e?.logoutRedirectUri});if(!y.isOkOr4xx(i))throw new Error(`Failed to end session; received ${i.status}`);return i}static async revokeToken(e){const{clientId:n}=w.get(e),s=await p.get(),t=s&&s.accessToken,i={client_id:n};t&&(i.token=t);const r={body:f.stringify(i),credentials:"include",headers:new Headers({"Content-Type":"application/x-www-form-urlencoded"}),method:"POST"},o=await this.request("revoke",void 0,!1,r,e);if(!y.isOkOr4xx(o))throw new Error(`Failed to revoke token; received ${o.status}`);return o}static async request(e,n,s,t,i,r){const{redirectUri:o,middleware:a,serverConfig:c}=w.get(i),d=r?.logoutRedirectUri?r.logoutRedirectUri:o,u=this.getUrl(e,n,i),m=g=>{switch(g){case"accessToken":return l.ActionTypes.ExchangeToken;case"endSession":return l.ActionTypes.EndSession;case"revoke":return l.ActionTypes.RevokeToken;default:return l.ActionTypes.UserInfo}};if(t=t||{},t.headers=t.headers||new Headers,t.headers.set("Accept","application/json"),s){const g=await p.get(),v=g&&g.accessToken;t.credentials="include",t.headers.set("Authorization",`Bearer ${v}`)}const h=T({url:new URL(u),init:t},{type:m(e)})(a);return m(e)===l.ActionTypes.EndSession&&r?.redirect===!0?(h.url.searchParams.append("post_logout_redirect_uri",d||""),window.location.assign(h.url.toString()),new Response):m(e)===l.ActionTypes.EndSession&&r?.redirect!==!1&&(r?.logoutRedirectUri||this.getUrl("endSession").includes("/as/signoff"))?(h.url.searchParams.append("post_logout_redirect_uri",d||""),window.location.assign(h.url.toString()),new Response):await q.withTimeout(fetch(h.url.toString(),h.init),c.timeout)}static containsAuthCode(e){return!!e&&/code=([^&]+)/.test(e)}static containsAuthError(e){return!!e&&/error=([^&]+)/.test(e)}static async getBody(e){const n=e.headers.get("Content-Type");return n&&n.indexOf("application/json")>-1?await e.json():await e.text()}static parseError(e){if(e){if(e.error&&e.error_description)return`${e.error}: ${e.error_description}`;if(e.code&&e.message)return`${e.code}: ${e.message}`}}static getUrl(e,n,s){const{realmPath:t,serverConfig:i}=w.get(s),r=f.getEndpointPath(e,t,i.paths);let o=f.resolve(i.baseUrl,r);return n&&(o+=`?${f.stringify(n)}`),o}}exports.allowedErrors=k;exports.default=A;
