import { WebAuthnOutcomeType as S } from "./enums.js";
import { getIndexOne as e, parsePubKeyArray as K, parseCredentials as O, ensureArray as y } from "./helpers.js";
function T(t) {
  const s = new TextEncoder(), r = e(t.match(/attestation"{0,}:\s{0,}"(\w+)"/)), c = Number(e(t.match(/timeout"{0,}:\s{0,}(\d+)/))), l = e(
    t.match(/userVerification"{0,}:\s{0,}"(\w+)"/)
  ), i = e(
    t.match(/requireResidentKey"{0,}:\s{0,}(\w+)/)
  ), o = e(
    t.match(/authenticatorAttachment"{0,}:\s{0,}"([\w-]+)/)
  ), m = e(t.match(/rp"{0,}:\s{0,}{([^}]+)}/)).trim(), a = e(m.match(/id"{0,}:\s{0,}"([^"]*)"/)), w = e(m.match(/name"{0,}:\s{0,}"([^"]*)"/)), n = e(t.match(/user"{0,}:\s{0,}{([^]{0,})},/)).trim(), u = e(n.match(/id"{0,}:\s{0,}Uint8Array.from\("([^"]+)"/)), d = e(n.match(/name"{0,}:\s{0,}"([\d\w._-]+)"/)), h = e(n.match(/displayName"{0,}:\s{0,}"([\d\w\s.@_-]+)"/)), p = e(
    // Capture the `pubKeyCredParams` without also matching `excludeCredentials` as well.
    // `excludeCredentials` values are very similar to this property, so we need to make sure
    // our last value doesn't end with "buffer", so we are only capturing objects that
    // end in a digit and possibly a space.
    t.match(/pubKeyCredParams"*:\s*\[([^]+\d\s*})\s*]/)
  ).trim(), A = K(p);
  if (!A) {
    const b = new Error("Missing pubKeyCredParams property from registration options");
    throw b.name = S.DataError, b;
  }
  const g = e(
    t.match(/excludeCredentials"{0,}:\s{0,}\[([^]+)\s{0,}]/)
  ).trim(), f = O(g), C = y(
    t.match(/challenge"{0,}:\s{0,}new\s{0,}(Uint|Int)8Array\(([^\)]+)/)
  ), N = JSON.parse(C[2]), I = new Int8Array(N).buffer;
  return {
    attestation: r,
    authenticatorSelection: {
      userVerification: l,
      // Only include authenticatorAttachment prop if the value is truthy
      ...o && { authenticatorAttachment: o },
      // Only include requireResidentKey prop if the value is of string "true"
      ...i === "true" && {
        requireResidentKey: !!i
      }
    },
    challenge: I,
    ...f.length && { excludeCredentials: f },
    pubKeyCredParams: A,
    rp: {
      name: w,
      // only add key-value pair if truthy value is provided
      ...a && { id: a }
    },
    timeout: c,
    user: {
      displayName: h,
      id: s.encode(u),
      name: d
    }
  };
}
function E(t) {
  let s, r;
  t.includes("acceptableCredentials") ? r = e(
    t.match(/acceptableCredentials"*\s*=\s*\[([^]+)\s*]/)
  ).trim() : r = e(
    t.match(/allowCredentials"{0,}:\s{0,}\[([^]+)\s{0,}]/)
  ).trim();
  const c = e(
    t.match(/userVerification"{0,}:\s{0,}"(\w+)"/)
  );
  r && (s = (r.split("},") || [r]).map((n) => {
    const u = e(n.match(/type"{0,}:\s{0,}"([\w-]+)"/)), d = y(n.match(/id"{0,}:\s{0,}new\s{0,}(Uint|Int)8Array\(([^\)]+)/)), h = JSON.parse(d[2]), p = new Int8Array(h).buffer;
    return {
      type: u,
      id: p
    };
  }));
  const l = Number(e(t.match(/timeout"{0,}:\s{0,}(\d+)/))), i = y(
    t.match(/challenge"{0,}:\s{0,}new\s{0,}(Uint|Int)8Array\(([^\)]+)/)
  ), o = JSON.parse(i[2]), m = new Int8Array(o).buffer, a = e(t.match(/rpId"{0,}:\s{0,}\\{0,}"([^"\\]*)/));
  return {
    challenge: m,
    timeout: l,
    // only add key-value pairs if the truthy values are provided
    ...s && { allowCredentials: s },
    ...c && { userVerification: c },
    ...a && { rpId: a }
  };
}
export {
  E as parseWebAuthnAuthenticateText,
  T as parseWebAuthnRegisterText
};
