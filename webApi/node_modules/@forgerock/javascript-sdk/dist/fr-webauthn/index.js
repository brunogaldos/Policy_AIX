import { CallbackType as p } from "../auth/enums.js";
import { WebAuthnStepType as h, WebAuthnOutcomeType as c, WebAuthnOutcome as g } from "./enums.js";
import { arrayBufferToString as m, parseRelyingPartyId as C, parseCredentials as w, parsePubKeyArray as k } from "./helpers.js";
import { parseWebAuthnAuthenticateText as E, parseWebAuthnRegisterText as $ } from "./script-parser.js";
class V {
  /**
   * Determines if the given step is a WebAuthn step.
   *
   * @param step The step to evaluate
   * @return A WebAuthnStepType value
   */
  static getWebAuthnStepType(e) {
    const a = this.getOutcomeCallback(e), t = this.getMetadataCallback(e), i = this.getTextOutputCallback(e);
    return a && t ? t.getOutputValue("data")?.pubKeyCredParams ? h.Registration : h.Authentication : a && i ? i.getMessage().includes("pubKeyCredParams") ? h.Registration : h.Authentication : h.None;
  }
  /**
   * Populates the step with the necessary authentication outcome.
   *
   * @param step The step that contains WebAuthn authentication data
   * @return The populated step
   */
  static async authenticate(e) {
    const { hiddenCallback: a, metadataCallback: t, textOutputCallback: i } = this.getCallbacks(e);
    if (a && (t || i)) {
      let o, n = null;
      try {
        let r;
        if (t) {
          const s = t.getOutputValue("data");
          r = this.createAuthenticationPublicKey(s), n = await this.getAuthenticationCredential(
            r
          ), o = this.getAuthenticationOutcome(n);
        } else if (i)
          r = E(i.getMessage()), n = await this.getAuthenticationCredential(
            r
          ), o = this.getAuthenticationOutcome(n);
        else
          throw new Error("No Credential found from Public Key");
      } catch (r) {
        throw r instanceof Error ? r.name === c.NotSupportedError ? (a.setInputValue(g.Unsupported), r) : (a.setInputValue(`${g.Error}::${r.name}:${r.message}`), r) : r;
      }
      return t && t.getOutputValue("data")?.supportsJsonResponse && n && "authenticatorAttachment" in n ? (a.setInputValue(
        JSON.stringify({
          authenticatorAttachment: n.authenticatorAttachment,
          legacyData: o
        })
      ), e) : (a.setInputValue(o), e);
    } else {
      const o = new Error("Incorrect callbacks for WebAuthn authentication");
      throw o.name = c.DataError, a?.setInputValue(`${g.Error}::${o.name}:${o.message}`), o;
    }
  }
  /**
   * Populates the step with the necessary registration outcome.
   *
   * @param step The step that contains WebAuthn registration data
   * @return The populated step
   */
  // Can make this generic const in Typescript 5.0 > and the name itself will
  // be inferred from the type so `typeof deviceName` will not just return string
  // but the actual name of the deviceName passed in as a generic.
  static async register(e, a) {
    const { hiddenCallback: t, metadataCallback: i, textOutputCallback: o } = this.getCallbacks(e);
    if (t && (i || o)) {
      let n, r = null;
      try {
        let s;
        if (i) {
          const l = i.getOutputValue("data");
          s = this.createRegistrationPublicKey(l), r = await this.getRegistrationCredential(
            s
          ), n = this.getRegistrationOutcome(r);
        } else if (o)
          s = $(o.getMessage()), r = await this.getRegistrationCredential(
            s
          ), n = this.getRegistrationOutcome(r);
        else
          throw new Error("No Credential found from Public Key");
      } catch (s) {
        throw s instanceof Error ? s.name === c.NotSupportedError ? (t.setInputValue(g.Unsupported), s) : (t.setInputValue(`${g.Error}::${s.name}:${s.message}`), s) : s;
      }
      return i && i.getOutputValue("data")?.supportsJsonResponse && r && "authenticatorAttachment" in r ? (t.setInputValue(
        JSON.stringify({
          authenticatorAttachment: r.authenticatorAttachment,
          legacyData: a && a.length > 0 ? `${n}::${a}` : n
        })
      ), e) : (t.setInputValue(
        a && a.length > 0 ? `${n}::${a}` : n
      ), e);
    } else {
      const n = new Error("Incorrect callbacks for WebAuthn registration");
      throw n.name = c.DataError, t?.setInputValue(`${g.Error}::${n.name}:${n.message}`), n;
    }
  }
  /**
   * Returns an object containing the two WebAuthn callbacks.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The WebAuthn callbacks
   */
  static getCallbacks(e) {
    const a = this.getOutcomeCallback(e), t = this.getMetadataCallback(e), i = this.getTextOutputCallback(e), o = {
      hiddenCallback: a
    };
    return t ? o.metadataCallback = t : i && (o.textOutputCallback = i), o;
  }
  /**
   * Returns the WebAuthn metadata callback containing data to pass to the browser
   * Web Authentication API.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The metadata callback
   */
  static getMetadataCallback(e) {
    return e.getCallbacksOfType(p.MetadataCallback).find((a) => {
      const t = a.getOutputByName("data", void 0);
      return t && t.hasOwnProperty("relyingPartyId");
    });
  }
  /**
   * Returns the WebAuthn hidden value callback where the outcome should be populated.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The hidden value callback
   */
  static getOutcomeCallback(e) {
    return e.getCallbacksOfType(p.HiddenValueCallback).find((a) => a.getOutputByName("id", "") === "webAuthnOutcome");
  }
  /**
   * Returns the WebAuthn metadata callback containing data to pass to the browser
   * Web Authentication API.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The metadata callback
   */
  static getTextOutputCallback(e) {
    return e.getCallbacksOfType(p.TextOutputCallback).find((a) => {
      const t = a.getOutputByName("message", void 0);
      return t && t.includes("webAuthnOutcome");
    });
  }
  /**
   * Retrieves the credential from the browser Web Authentication API.
   *
   * @param options The public key options associated with the request
   * @return The credential
   */
  static async getAuthenticationCredential(e) {
    if (!window.PublicKeyCredential) {
      const t = new Error("PublicKeyCredential not supported by this browser");
      throw t.name = c.NotSupportedError, t;
    }
    return await navigator.credentials.get({ publicKey: e });
  }
  /**
   * Converts an authentication credential into the outcome expected by OpenAM.
   *
   * @param credential The credential to convert
   * @return The outcome string
   */
  static getAuthenticationOutcome(e) {
    if (e === null) {
      const a = new Error("No credential generated from authentication");
      throw a.name = c.UnknownError, a;
    }
    try {
      const a = m(e.response.clientDataJSON), t = e.response, i = new Int8Array(
        t.authenticatorData
      ).toString(), o = new Int8Array(t.signature).toString(), n = m(e.response.userHandle);
      let r = `${a}::${i}::${o}::${e.id}`;
      return n && (r = `${r}::${n}`), r;
    } catch {
      const t = new Error("Transforming credential object to string failed");
      throw t.name = c.EncodingError, t;
    }
  }
  /**
   * Retrieves the credential from the browser Web Authentication API.
   *
   * @param options The public key options associated with the request
   * @return The credential
   */
  static async getRegistrationCredential(e) {
    if (!window.PublicKeyCredential) {
      const t = new Error("PublicKeyCredential not supported by this browser");
      throw t.name = c.NotSupportedError, t;
    }
    return await navigator.credentials.create({
      publicKey: e
    });
  }
  /**
   * Converts a registration credential into the outcome expected by OpenAM.
   *
   * @param credential The credential to convert
   * @return The outcome string
   */
  static getRegistrationOutcome(e) {
    if (e === null) {
      const a = new Error("No credential generated from registration");
      throw a.name = c.UnknownError, a;
    }
    try {
      const a = m(e.response.clientDataJSON), t = e.response, i = new Int8Array(
        t.attestationObject
      ).toString();
      return `${a}::${i}::${e.id}`;
    } catch {
      const t = new Error("Transforming credential object to string failed");
      throw t.name = c.EncodingError, t;
    }
  }
  /**
   * Converts authentication tree metadata into options required by the browser
   * Web Authentication API.
   *
   * @param metadata The metadata provided in the authentication tree MetadataCallback
   * @return The Web Authentication API request options
   */
  static createAuthenticationPublicKey(e) {
    const {
      acceptableCredentials: a,
      allowCredentials: t,
      challenge: i,
      relyingPartyId: o,
      timeout: n,
      userVerification: r
    } = e, s = C(o), l = w(t || a || "");
    return {
      challenge: Uint8Array.from(atob(i), (d) => d.charCodeAt(0)).buffer,
      timeout: n,
      // only add key-value pair if proper value is provided
      ...l && { allowCredentials: l },
      ...r && { userVerification: r },
      ...s && { rpId: s }
    };
  }
  /**
   * Converts authentication tree metadata into options required by the browser
   * Web Authentication API.
   *
   * @param metadata The metadata provided in the authentication tree MetadataCallback
   * @return The Web Authentication API request options
   */
  static createRegistrationPublicKey(e) {
    const { pubKeyCredParams: a } = e, t = k(a);
    if (!t) {
      const u = new Error("Missing pubKeyCredParams property from registration options");
      throw u.name = c.DataError, u;
    }
    const i = w(e.excludeCredentials), {
      attestationPreference: o,
      authenticatorSelection: n,
      challenge: r,
      relyingPartyId: s,
      relyingPartyName: l,
      timeout: d,
      userId: O,
      userName: b,
      displayName: y
    } = e, f = C(s), A = {
      name: l,
      ...f && { id: f }
    };
    return {
      attestation: o,
      authenticatorSelection: JSON.parse(n),
      challenge: Uint8Array.from(atob(r), (u) => u.charCodeAt(0)).buffer,
      ...i.length && { excludeCredentials: i },
      pubKeyCredParams: t,
      rp: A,
      timeout: d,
      user: {
        displayName: y || b,
        id: Int8Array.from(O.split("").map((u) => u.charCodeAt(0))),
        name: y || b
      }
    };
  }
}
export {
  g as WebAuthnOutcome,
  h as WebAuthnStepType,
  V as default
};
