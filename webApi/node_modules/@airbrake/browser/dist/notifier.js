"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Notifier = void 0;
var promise_polyfill_1 = __importDefault(require("promise-polyfill"));
var base_notifier_1 = require("./base_notifier");
var window_1 = require("./filter/window");
var console_1 = require("./instrumentation/console");
var dom_1 = require("./instrumentation/dom");
var fetch_1 = require("./instrumentation/fetch");
var location_1 = require("./instrumentation/location");
var xhr_1 = require("./instrumentation/xhr");
var unhandledrejection_1 = require("./instrumentation/unhandledrejection");
var Notifier = /** @class */ (function (_super) {
    __extends(Notifier, _super);
    function Notifier(opt) {
        var _this = _super.call(this, opt) || this;
        _this.offline = false;
        _this.todo = [];
        _this._ignoreWindowError = 0;
        _this._ignoreNextXHR = 0;
        if (typeof window === 'undefined') {
            return _this;
        }
        _this.addFilter(window_1.windowFilter);
        if (window.addEventListener) {
            _this.onOnline = _this.onOnline.bind(_this);
            window.addEventListener('online', _this.onOnline);
            _this.onOffline = _this.onOffline.bind(_this);
            window.addEventListener('offline', _this.onOffline);
            _this._onClose.push(function () {
                window.removeEventListener('online', _this.onOnline);
                window.removeEventListener('offline', _this.onOffline);
            });
        }
        _this._instrument(opt.instrumentation);
        return _this;
    }
    Notifier.prototype._instrument = function (opt) {
        if (opt === void 0) { opt = {}; }
        if (opt.console === undefined) {
            opt.console = !isDevEnv(this._opt.environment);
        }
        if (enabled(opt.onerror)) {
            // tslint:disable-next-line:no-this-assignment
            var self_1 = this;
            var oldHandler_1 = window.onerror;
            window.onerror = function abOnerror() {
                if (oldHandler_1) {
                    oldHandler_1.apply(this, arguments);
                }
                self_1.onerror.apply(self_1, arguments);
            };
        }
        (0, dom_1.instrumentDOM)(this);
        if (enabled(opt.fetch) && typeof fetch === 'function') {
            (0, fetch_1.instrumentFetch)(this);
        }
        if (enabled(opt.history) && typeof history === 'object') {
            (0, location_1.instrumentLocation)(this);
        }
        if (enabled(opt.console) && typeof console === 'object') {
            (0, console_1.instrumentConsole)(this);
        }
        if (enabled(opt.xhr) && typeof XMLHttpRequest !== 'undefined') {
            (0, xhr_1.instrumentXHR)(this);
        }
        if (enabled(opt.unhandledrejection) &&
            typeof addEventListener === 'function') {
            (0, unhandledrejection_1.instrumentUnhandledrejection)(this);
        }
    };
    Notifier.prototype.notify = function (err) {
        var _this = this;
        if (this.offline) {
            return new promise_polyfill_1.default(function (resolve, reject) {
                _this.todo.push({
                    err: err,
                    resolve: resolve,
                    reject: reject,
                });
                while (_this.todo.length > 100) {
                    var j = _this.todo.shift();
                    if (j === undefined) {
                        break;
                    }
                    j.resolve({
                        error: new Error('airbrake: offline queue is too large'),
                    });
                }
            });
        }
        return _super.prototype.notify.call(this, err);
    };
    Notifier.prototype.onOnline = function () {
        this.offline = false;
        var _loop_1 = function (j) {
            this_1.notify(j.err).then(function (notice) {
                j.resolve(notice);
            });
        };
        var this_1 = this;
        for (var _i = 0, _a = this.todo; _i < _a.length; _i++) {
            var j = _a[_i];
            _loop_1(j);
        }
        this.todo = [];
    };
    Notifier.prototype.onOffline = function () {
        this.offline = true;
    };
    Notifier.prototype.onerror = function (message, filename, line, column, err) {
        if (this._ignoreWindowError > 0) {
            return;
        }
        if (err) {
            this.notify({
                error: err,
                context: {
                    windowError: true,
                },
            });
            return;
        }
        // Ignore errors without file or line.
        if (!filename || !line) {
            return;
        }
        this.notify({
            error: {
                message: message,
                fileName: filename,
                lineNumber: line,
                columnNumber: column,
                noStack: true,
            },
            context: {
                windowError: true,
            },
        });
    };
    Notifier.prototype._ignoreNextWindowError = function () {
        var _this = this;
        this._ignoreWindowError++;
        setTimeout(function () { return _this._ignoreWindowError--; });
    };
    return Notifier;
}(base_notifier_1.BaseNotifier));
exports.Notifier = Notifier;
function isDevEnv(env) {
    return env && env.startsWith && env.startsWith('dev');
}
function enabled(v) {
    return v === undefined || v === true;
}
//# sourceMappingURL=notifier.js.map