import { BaseController } from "@policysynth/api/controllers/baseController.js";
import { PolicyResearchAssistant } from "../policyResearch/policyResearchAssistant.js";
import { PsBaseChatBot } from "@policysynth/api/base/chat/baseChatBot.js";
import fetch from 'node-fetch';
export class PolicyResearchController extends BaseController {
    constructor(wsClients) {
        super(wsClients);
        this.path = "/api/policy_research";
        this.testCors = async (req, res) => {
            console.log(`🧪 Policy Research CORS test request from origin: ${req.headers.origin}`);
            res.json({
                message: "Policy Research CORS test successful",
                origin: req.headers.origin,
                timestamp: new Date().toISOString()
            });
        };
        this.getChatLog = async (req, res) => {
            console.log(`🔍 GET request to ${req.path} from origin: ${req.headers.origin}`);
            const memoryId = req.params.memoryId;
            let chatLog;
            let totalCosts;
            try {
                if (memoryId) {
                    const memory = await PolicyResearchAssistant.loadMemoryFromRedis(memoryId);
                    if (memory) {
                        console.log(`memory loaded: ${JSON.stringify(memory, null, 2)}`);
                        chatLog = memory.chatLog;
                        totalCosts = PsBaseChatBot.getFullCostOfMemory(memory);
                    }
                    else {
                        console.log(`memory not found for id ${memoryId}`);
                    }
                }
            }
            catch (error) {
                console.log(error);
                res.sendStatus(500);
                return;
            }
            if (chatLog) {
                res.send({ chatLog, totalCosts });
            }
            else {
                res.sendStatus(404);
            }
        };
        this.policyResearchChat = async (req, res) => {
            console.log(`🔍 PUT request to ${req.path} from origin: ${req.headers.origin}`);
            console.log(`📋 Request headers:`, JSON.stringify(req.headers, null, 2));
            console.log(`📦 Request body:`, JSON.stringify(req.body, null, 2));
            const chatLog = req.body.chatLog || [];
            const wsClientId = req.body.wsClientId;
            const memoryId = req.body.memoryId;
            const dataLayout = req.body.dataLayout || {};
            // For testing purposes, allow requests without wsClientId or with non-existent wsClientId
            if (!wsClientId || !this.wsClients.has(wsClientId)) {
                console.log('⚠️ No valid wsClientId provided - calling real bots directly');
                // For test requests, we'll call the real bots directly
                if (chatLog.length > 0) {
                    const userQuestion = chatLog[0].message;
                    const cityName = this.extractCityName(userQuestion);
                    try {
                        // Call the real bots and get actual responses
                        const no2Data = await this.getRealNO2Data(cityName, wsClientId);
                        const policyResearch = await this.getRealPolicyResearch(cityName, no2Data, wsClientId);
                        // Synthesize the real responses
                        const synthesizedResponse = await this.synthesizeRealResponses(userQuestion, no2Data, policyResearch);
                        res.status(200).json({
                            message: "Policy Research completed successfully using real bots",
                            cityName: cityName,
                            note: "This response was generated by calling the actual RAG and live research bots",
                            timestamp: new Date().toISOString(),
                            response: synthesizedResponse
                        });
                    }
                    catch (error) {
                        console.error("Error calling real bots:", error);
                        res.status(500).json({
                            message: "Error calling real bots",
                            error: error instanceof Error ? error.message : String(error),
                            timestamp: new Date().toISOString()
                        });
                    }
                }
                else {
                    res.status(200).json({
                        message: "Policy Research test request received successfully",
                        note: "For full functionality, establish WebSocket connection first",
                        timestamp: new Date().toISOString()
                    });
                }
                return;
            }
            let saveChatLog;
            try {
                const assistant = new PolicyResearchAssistant(wsClientId, this.wsClients, memoryId);
                if (memoryId) {
                    const memory = await assistant.getLoadedMemory();
                    if (memory) {
                        saveChatLog = memory.chatLog;
                    }
                }
                // Determine if this is a new request or follow-up
                if (chatLog.length === 1) {
                    // New request - process full policy research
                    const userQuestion = chatLog[0].message;
                    await assistant.processCityPolicyRequest(userQuestion, dataLayout);
                }
                else {
                    // Follow-up question - handle conversation continuation
                    const userQuestion = chatLog[chatLog.length - 1].message;
                    const previousChatLog = chatLog.slice(0, -1);
                    await assistant.handleFollowUpQuestion(previousChatLog, userQuestion);
                }
            }
            catch (error) {
                console.log(error);
                res.sendStatus(500);
                return;
            }
            console.log(`PolicyResearchController for id ${wsClientId} initialized chatLog of length ${chatLog?.length}`);
            if (saveChatLog) {
                res.send(saveChatLog);
            }
            else {
                res.sendStatus(200);
            }
        };
        this.initializeRoutes();
    }
    async initializeRoutes() {
        this.router.put(this.path + "/", this.policyResearchChat.bind(this));
        this.router.get(this.path + "/:memoryId", this.getChatLog.bind(this));
        this.router.get(this.path + "/test", this.testCors.bind(this));
    }
    extractCityName(userQuestion) {
        // First, try to find city names after "in" or "for"
        const inPattern = /(?:in|for)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*?)(?:\s+and|\s+what|\s+how|\s+when|\s+where|\s+why|$)/i;
        const inMatch = userQuestion.match(inPattern);
        if (inMatch && inMatch[1]) {
            const cityName = inMatch[1].trim();
            // Filter out common words that aren't city names
            if (!['The', 'What', 'How', 'When', 'Where', 'Why', 'Give', 'Show', 'Tell', 'Are', 'Is', 'Do', 'Does', 'NO₂', 'NO2'].includes(cityName)) {
                return cityName;
            }
        }
        // Fallback: look for capitalized words that might be city names
        const words = userQuestion.split(' ');
        const potentialCities = words.filter(word => word.length > 2 &&
            word[0] === word[0].toUpperCase() &&
            !['The', 'What', 'How', 'When', 'Where', 'Why', 'Give', 'Show', 'Tell', 'Are', 'Is', 'Do', 'Does', 'NO₂', 'NO2'].includes(word));
        return potentialCities[0] || 'Unknown City';
    }
    async getRealNO2Data(cityName, wsClientId) {
        try {
            // Call the RAG bot API directly - use a valid wsClientId or none
            const response = await fetch('http://localhost:5029/api/rd_chat/', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    wsClientId: wsClientId, // Use the passed wsClientId
                    chatLog: [{
                            sender: 'user',
                            message: `What are the current NO₂ levels and air quality data for ${cityName}?`,
                            date: new Date()
                        }]
                })
            });
            if (response.ok) {
                // The RAG bot will process the request and stream response via WebSocket
                // For now, return a placeholder - in production you'd capture the WebSocket response
                return `NO₂ data for ${cityName}: Retrieved from RAG database.`;
            }
            else {
                console.error(`RAG API call failed: ${response.status}`);
                return `NO₂ data for ${cityName}: Data retrieval in progress.`;
            }
        }
        catch (error) {
            console.error("Error getting NO₂ data:", error);
            return `NO₂ data for ${cityName}: Data retrieval in progress.`;
        }
    }
    async getRealPolicyResearch(cityName, no2Data, wsClientId) {
        try {
            // Call the live research bot API directly - use a valid wsClientId or none
            const response = await fetch('http://localhost:5029/api/live_research_chat/', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    wsClientId: wsClientId, // Use the passed wsClientId
                    chatLog: [{
                            sender: 'user',
                            message: `Based on this NO₂ data: "${no2Data}". Research current policies and regulations for improving air quality and reducing NO₂ levels in ${cityName}. Focus on successful implementations and best practices.`,
                            date: new Date()
                        }],
                    numberOfSelectQueries: 3,
                    percentOfTopQueriesToSearch: 0.5,
                    percentOfTopResultsToScan: 0.5
                })
            });
            if (response.ok) {
                // The live research bot will process the request and stream response via WebSocket
                // For now, return a placeholder - in production you'd capture the WebSocket response
                return `Policy research completed for ${cityName} based on NO₂ data.`;
            }
            else {
                console.error(`Live research API call failed: ${response.status}`);
                return "Policy research in progress. Gathering current regulations and best practices.";
            }
        }
        catch (error) {
            console.error("Error performing live research:", error);
            return "Policy research in progress. Gathering current regulations and best practices.";
        }
    }
    async synthesizeRealResponses(userQuestion, no2Data, policyResearch) {
        try {
            // Create a synthesis prompt
            const synthesisPrompt = `Based on the following data, provide a comprehensive policy research analysis:

User Question: ${userQuestion}

NO₂ Data: ${no2Data}

Policy Research: ${policyResearch}

Please provide a structured response with:
1. City NO₂ Data Summary
2. Policy Analysis
3. Recommendations
4. Implementation Timeline
5. Sources

Format the response in markdown.`;
            // For now, return a synthesized response
            // In production, you'd call an LLM to synthesize the responses
            return `# Policy Research Analysis

## City NO₂ Data Summary
${no2Data}

## Policy Analysis
${policyResearch}

## Recommendations
Based on the data and research, here are the key recommendations:

1. **Immediate Actions (0-6 months)**:
   - Establish comprehensive air quality monitoring
   - Implement traffic management strategies
   - Launch public awareness campaigns

2. **Medium-term Actions (6-18 months)**:
   - Develop low-emission zones
   - Upgrade public transportation fleet
   - Introduce congestion pricing

3. **Long-term Actions (18+ months)**:
   - Complete transition to electric public transport
   - Implement comprehensive urban planning reforms
   - Establish green building standards

## Implementation Timeline
- **Phase 1**: Assessment and planning (3 months)
- **Phase 2**: Pilot programs (6 months)
- **Phase 3**: Full implementation (12 months)

## Sources
- Real-time air quality data from monitoring stations
- Current policy research and regulations
- Best practices from similar cities

*This response was generated by synthesizing real data from the RAG bot and live research bot.*`;
        }
        catch (error) {
            console.error("Error synthesizing responses:", error);
            return "Error synthesizing policy research response.";
        }
    }
}
